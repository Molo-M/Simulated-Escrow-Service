import assert from 'assert';
import removeSlash from 'remove-trailing-slash';
import axios from 'axios';
import axiosRetry from 'axios-retry';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */


function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, [])).next());
    });
}

const version = '1.0.11';

/**
 *
 *  Throws when no response was received from the server
 *  @param message - error message
 *
 * */
class ApiRequestError extends Error {
    constructor(message) {
        super(message);
        this.name = 'ApiRequestError';
    }
}

/**
 *
 *  Throws when the server responds with a status code that falls out of the range 2xx
 *  @param statusCode - HTTP status code the server responded with
 *  @param message - error message
 *
 * */
class ApiResponseError extends Error {
    constructor(statusCode, message) {
        super(`(${statusCode}): ${message}`);
        this.statusCode = statusCode;
        this.name = 'ApiResponseError';
    }
}

class ApiRequest {
    constructor(config) {
        const { host, accessKey, headers, retryCount } = config;
        this.host = host;
        this.accessKey = accessKey;
        this.headers = this._generateDefaultHeaders();
        this.retryCount = retryCount !== null && retryCount !== void 0 ? retryCount : 3;
        if (headers) {
            this.headers = Object.assign(Object.assign({}, this.headers), { headers });
        }
        this._init();
    }
    _init() {
        var _a;
        const isoDateFormat = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d*)?(?:[-+]\d{2}:?\d{2}|Z)?$/;
        function isIsoDateString(value) {
            return value && typeof value === 'string' && isoDateFormat.test(value);
        }
        function handleDates(body) {
            if (body === null || body === undefined || typeof body !== 'object') {
                return body;
            }
            for (const key of Object.keys(body)) {
                const value = body[key];
                if (isIsoDateString(value)) {
                    body[key] = new Date(value);
                }
                else if (typeof value === 'object') {
                    handleDates(value);
                }
            }
        }
        axios.interceptors.response.use((response) => {
            handleDates(response.data);
            return response;
        });
        axiosRetry(axios, {
            retries: (_a = this.retryCount) !== null && _a !== void 0 ? _a : 3,
            retryCondition: this._isErrorRetryable,
            retryDelay: axiosRetry.exponentialDelay,
        });
    }
    request(method, endpoint, payload) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield axios.request({
                    baseURL: this.host,
                    method: method,
                    url: endpoint,
                    data: payload,
                    headers: this.headers,
                });
                return response.data;
            }
            catch (error) {
                if (axios.isAxiosError(error)) {
                    if (error.response) {
                        throw new ApiResponseError(error.response.status, (_a = error.response.data.message) !== null && _a !== void 0 ? _a : error.response.statusText);
                    }
                    else if (error.request) {
                        throw new ApiRequestError(error.message);
                    }
                }
                throw error;
            }
        });
    }
    _generateDefaultHeaders() {
        return {
            'user-agent': `theauthapi-client-node/${version}`,
            'x-api-key': this.accessKey,
            'api-key': this.accessKey,
        };
    }
    _isErrorRetryable(error) {
        // Retry Network Errors.
        if (axiosRetry.isNetworkError(error)) {
            return true;
        }
        if (!error.response) {
            // Cannot determine if the request can be retried
            return false;
        }
        // Retry Server Errors (5xx).
        if (error.response.status >= 500 && error.response.status <= 599) {
            return true;
        }
        // Retry if rate limited.
        if (error.response.status === 429) {
            return true;
        }
        return false;
    }
}

var HttpMethod;
(function (HttpMethod) {
    HttpMethod["GET"] = "GET";
    HttpMethod["POST"] = "POST";
    HttpMethod["DELETE"] = "DELETE";
    HttpMethod["PATCH"] = "PATCH";
    HttpMethod["PUT"] = "PUT";
})(HttpMethod || (HttpMethod = {}));

class ApiKeys {
    constructor(apiService) {
        this.api = apiService;
        this.endpoint = '/api-keys/';
    }
    isValidKey(apikey) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const key = yield this.authenticateKey(apikey);
                return key.key !== undefined;
            }
            catch (error) {
                if (error instanceof ApiResponseError && error.statusCode === 404) {
                    return false;
                }
                throw error;
            }
        });
    }
    authenticateKey(apikey) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.api.request(HttpMethod.POST, `/api-keys/auth/${apikey}`);
        });
    }
    getKeys(filter) {
        return __awaiter(this, void 0, void 0, function* () {
            const endpoint = this.getKeysFilterEndpoint(filter);
            return yield this.api.request(HttpMethod.GET, endpoint);
        });
    }
    getKey(apikey) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.api.request(HttpMethod.GET, `/api-keys/${apikey}`);
        });
    }
    createKey(apiKey) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.api.request(HttpMethod.POST, '/api-keys', apiKey);
        });
    }
    updateKey(apiKey, updatedKey) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.api.request(HttpMethod.PATCH, `/api-keys/${apiKey}`, updatedKey);
        });
    }
    deleteKey(apiKey) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.api.request(HttpMethod.DELETE, `/api-keys/${apiKey}`);
        });
    }
    reactivateKey(apiKey) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.api.request(HttpMethod.PATCH, `/api-keys/${apiKey}/reactivate`);
        });
    }
    rotateKey(apiKey) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.api.request(HttpMethod.POST, `/api-keys/${apiKey}/rotate`);
        });
    }
    getKeysFilterEndpoint(filter) {
        let filters = [];
        if (filter !== undefined) {
            filters = Object.entries(filter).map(([key, value]) => `${key}=${value}`);
        }
        return `${this.endpoint}${filter !== undefined ? '?' : ''}${filters.join('&')}`;
    }
}

class Projects {
    constructor(apiService) {
        this.api = apiService;
        this.endpoint = '/projects';
    }
    getProjects(accountId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.api.request(HttpMethod.GET, `${this.endpoint}?accountId=${accountId}`);
        });
    }
    getProject(projectId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.api.request(HttpMethod.GET, `${this.endpoint}/${projectId}`);
        });
    }
    deleteProject(projectId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.api.request(HttpMethod.DELETE, `${this.endpoint}/${projectId}`);
        });
    }
    createProject(project) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.api.request(HttpMethod.POST, this.endpoint, project);
        });
    }
    updateProject(projectId, project) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.api.request(HttpMethod.PATCH, `${this.endpoint}/${projectId}`, project);
        });
    }
}

class Accounts {
    constructor(apiService) {
        this.api = apiService;
        this.endpoint = '/accounts';
    }
    getAccount(accountId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.api.request(HttpMethod.GET, `${this.endpoint}/${accountId}`);
        });
    }
}

// eslint-disable-next-line @typescript-eslint/no-empty-function
const noop = () => { };
class TheAuthAPI {
    /**
     * @param {String} accessKey
     * @param {Object} [options] (optional)
     *   @property {String} host (default: 'https://api.segment.io')
     *   @property {number} retryCount (default: 3)
     */
    constructor(accessKey, options) {
        var _a;
        assert(accessKey, "You must pass your project's write key.");
        this.accessKey = accessKey;
        this.host = removeSlash((options === null || options === void 0 ? void 0 : options.host) || 'https://api.theauthapi.com');
        this.api = new ApiRequest({
            accessKey: this.accessKey,
            host: this.host,
            retryCount: (_a = options === null || options === void 0 ? void 0 : options.retryCount) !== null && _a !== void 0 ? _a : 3,
        });
        this.apiKeys = new ApiKeys(this.api);
        this.projects = new Projects(this.api);
        this.accounts = new Accounts(this.api);
    }
    /*
      @deprecated
     */
    authenticateAPIKey(key, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const cb = callback || noop;
            const done = (err) => {
                cb(err, data);
            };
            const data = {
                credentials: { api_key: key },
                timestamp: new Date().getTime(),
                sentAt: new Date().getTime(),
            };
            try {
                const key = yield this.api.request(HttpMethod.POST, '/auth/authenticate', data);
                done(key);
                return key;
            }
            catch (err) {
                if (err.response) {
                    const error = new Error(err.response.statusText);
                    return done(error);
                }
                done(err);
            }
        });
    }
}

export { TheAuthAPI as default };
